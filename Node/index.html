<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="icon" href="/image/logo.png"><title>Node | 一条奇怪鱼</title><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="description" content="Node.js 就是运行在服务端的 JavaScript Node.js 是一个事件驱动 I&#x2F;O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好 创建应用组成 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块  12&#x2F;&#x2F; 我们使用 require 指令来载"><meta property="og:type" content="article"><meta property="og:title" content="Node"><meta property="og:url" content="https://blog.qiguaiyu.com/Node/index.html"><meta property="og:site_name" content="一条奇怪鱼"><meta property="og:description" content="Node.js 就是运行在服务端的 JavaScript Node.js 是一个事件驱动 I&#x2F;O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好 创建应用组成 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块  12&#x2F;&#x2F; 我们使用 require 指令来载"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-12-23T14:00:00.000Z"><meta property="article:modified_time" content="2022-12-23T17:09:06.610Z"><meta property="article:author" content="Duibing"><meta property="article:tag" content="一条奇怪鱼"><meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/image/logo.png"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-title" class="inner"><h1 id="logo-wrap"> <a href="/" id="logo">一条奇怪鱼</a></h1></div><div id="header-inner" class="inner"><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/">主页</a> <a class="main-nav-link" href="/archives">归档</a></nav></div></div></header><div class="outer"><section id="main"><article id="post-Node" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"> <a href="/Node/" class="article-date"><time class="dt-published" datetime="2022-12-23T14:00:00.000Z" itemprop="datePublished">2022-12-23</time></a></div><div class="article-inner"><header class="article-header"><h1 class="p-name article-title" itemprop="headline name"> Node</h1></header><div class="article-entry" itemprop="articleBody"><p> Node.js 就是运行在服务端的 JavaScript</p><p>Node.js 是一个事件驱动 I&#x2F;O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好</p><h1 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ol><li><strong>引入 required 模块</strong>：我们可以使用 <strong>require</strong> 指令来载入 Node.js 模块</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下</span><br><span class="line">var http = require(<span class="string">&quot;http&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>创建服务器</strong>：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。</span><br><span class="line"></span><br><span class="line">实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码</span><br><span class="line"></span><br><span class="line">var http = require(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="keyword">function</span> (request, response) &#123;</span><br><span class="line"></span><br><span class="line">    // 发送 HTTP 头部 </span><br><span class="line">    // HTTP 状态值: 200 : OK</span><br><span class="line">    // 内容类型: text/plain</span><br><span class="line">    response.writeHead(200, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    // 发送响应数据 <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    response.end(<span class="string">&#x27;Hello World\n&#x27;</span>);</span><br><span class="line">&#125;).listen(8888);</span><br><span class="line"></span><br><span class="line">// 终端打印如下信息</span><br><span class="line">console.log(<span class="string">&#x27;Server running at http://127.0.0.1:8888/&#x27;</span>);</span><br></pre></td></tr></table></figure><p>以上代码我们完成了一个可以工作的 HTTP 服务器。</p><ol start="3"><li><strong>接收请求与响应请求</strong> 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据</li></ol><p>使用 node 命令执行以上的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node server.js</span><br><span class="line">Server running at http://127.0.0.1:8888/</span><br></pre></td></tr></table></figure><p>接下来，打开浏览器访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:8888/">http://127.0.0.1:8888/</a></p><p>你会看到一个写着”Hello World”的网页</p><blockquote><p>如果我们使用 PHP 来编写后端的代码时，需要 Apache 或者 Nginx 的 HTTP 服务器，并配上 mod_php5 模块和 php-cgi</p><p>从这个角度看，整个”接收 HTTP 请求并提供 Web 页面”的需求就不需要 PHP 来处理</p><p>使用 Node.js 时，我们不仅仅 在实现一个应用，同时还实现了整个 HTTP 服务器</p></blockquote><h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>Node.js 异步编程的直接体现就是回调</p><p>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了</p><p>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数</p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><ul><li><p>Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。</p></li><li><p>Node.js 几乎每一个 API 都是支持回调函数的。</p></li><li><p>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</p></li><li><p>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.</p></li></ul><h2 id="事件驱动程序"><a href="#事件驱动程序" class="headerlink" title="事件驱动程序"></a>事件驱动程序</h2><p>Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。</p><p>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p><p>这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）</p><p>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p><p>整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。</p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 引入 events 模块</span><br><span class="line">var events = require(&#x27;events&#x27;);</span><br><span class="line">// 创建 eventEmitter 对象</span><br><span class="line">var eventEmitter = new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">// 创建事件处理程序</span><br><span class="line">var connectHandler = function connected() &#123;</span><br><span class="line">   console.log(&#x27;连接成功。&#x27;);</span><br><span class="line"></span><br><span class="line">   // 触发 data_received 事件 </span><br><span class="line">   eventEmitter.emit(&#x27;data_received&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 绑定 connection 事件处理程序</span><br><span class="line">eventEmitter.on(&#x27;connection&#x27;, connectHandler);</span><br><span class="line"></span><br><span class="line">// 使用匿名函数绑定 data_received 事件</span><br><span class="line">eventEmitter.on(&#x27;data_received&#x27;, function()&#123;</span><br><span class="line">   console.log(&#x27;数据接收成功。&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 触发 connection 事件 </span><br><span class="line">eventEmitter.emit(&#x27;connection&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;程序执行完毕。&quot;);</span><br></pre></td></tr></table></figure><h1 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h1><p>为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统</p><p>换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C&#x2F;C++ 扩展</p><h2 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h2><p>例：</p><p>创建一个 <strong>main.js</strong> 文件并引入 hello 模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello = require(&#x27;./hello&#x27;);</span><br><span class="line">hello.world();</span><br></pre></td></tr></table></figure><p>代码 require(‘.&#x2F;hello’) 引入了当前目录下的 hello.js 文件（.&#x2F; 为当前目录，node.js 默认后缀为 js）</p><blockquote><p>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象</p></blockquote><p>创建 hello.js 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.world = function() &#123;</span><br><span class="line">  console.log(&#x27;Hello World&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个对象封装到模块中，格式如下："><a href="#一个对象封装到模块中，格式如下：" class="headerlink" title="一个对象封装到模块中，格式如下："></a>一个对象封装到模块中，格式如下：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//hello.js </span><br><span class="line">function Hello() &#123; </span><br><span class="line">    var name; </span><br><span class="line">    this.setName = function(thyName) &#123; </span><br><span class="line">        name = thyName; </span><br><span class="line">    &#125;; </span><br><span class="line">    this.sayHello = function() &#123; </span><br><span class="line">        console.log(&#x27;Hello &#x27; + name); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line">module.exports = Hello;</span><br></pre></td></tr></table></figure><p>这样就可以直接获得这个对象了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//main.js </span><br><span class="line">var Hello = require(&#x27;./hello&#x27;); </span><br><span class="line">hello = new Hello(); </span><br><span class="line">hello.setName(&#x27;BYVoid&#x27;); </span><br><span class="line">hello.sayHello(); </span><br></pre></td></tr></table></figure><p>模块接口的唯一变化是使用 module.exports &#x3D; Hello 代替了exports.world &#x3D; function(){}</p><p>在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports</p><blockquote><p>不建议同时使用 exports 和 module.exports</p><p>如果先使用 exports 对外暴露属性或方法，再使用 module.exports 暴露对象，会使得 exports 上暴露的属性或者方法失效</p></blockquote><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>在 JavaScript中，一个函数可以作为另一个函数的参数</p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function say(word) &#123;</span><br><span class="line">  console.log(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function execute(someFunction, value) &#123;</span><br><span class="line">  someFunction(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execute(say, &quot;Hello&quot;);</span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function execute(someFunction, value) &#123;</span><br><span class="line">  someFunction(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execute(function(word)&#123; console.log(word) &#125;, &quot;Hello&quot;);</span><br></pre></td></tr></table></figure><p>用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数</p><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><p>我们都知道 Node.js 是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。</p><hr><h1 id="BUG修复"><a href="#BUG修复" class="headerlink" title="BUG修复"></a>BUG修复</h1><h2 id="Error-Cannot-find-module-‘node-process’"><a href="#Error-Cannot-find-module-‘node-process’" class="headerlink" title="Error: Cannot find module ‘node:process’"></a>Error: Cannot find module ‘node:process’</h2><p>错误代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&#x27;node:process&#x27;);</span><br></pre></td></tr></table></figure><p>节点内部语法（例如：Node.js<core_module_name>14.16.0不支持节点：）</core_module_name></p><p>解决方法：</p><p><strong>升级版本14.9.0或更高版本</strong></p></div><footer class="article-footer"></footer></div><nav id="article-nav"> <a href="/NPM/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">后一篇</strong><div class="article-nav-title">NPM</div></a></nav></article></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">归档</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">最新文章</h3><div class="widget"><ul><li> <a href="/Node/">Node</a></li><li> <a href="/NPM/">NPM</a></li><li> <a href="/live2d/">live2d</a></li><li> <a href="/HashMap%E9%81%8D%E5%8E%86%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">HashMap遍历性能分析</a></li><li> <a href="/Java/">Java</a></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"> &copy; 2022 Duibing<br> Powered by <a href="https://qiguaiyu.com/" target="_blank">qiguaiyu.com</a></div></div></footer></div><nav id="mobile-nav"> <a href="/" class="mobile-nav-link">主页</a> <a href="/archives" class="mobile-nav-link">归档</a></nav><script src="/js/jquery-3.4.1.min.js"></script><script src="/fancybox/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></div></body></html>
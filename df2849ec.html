<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="icon" href="/image/logo.png"><title>Java | 一条奇怪鱼</title><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="description" content="Java 语言有哪些特点? 面向对象（封装，继承，多态）  平台无关性（ Java 虚拟机实现平台无关性）  支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）  编译与解释并存   队列Queue 与 Deque 的区别Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（"><meta property="og:type" content="article"><meta property="og:title" content="Java"><meta property="og:url" content="https://blog.qiguaiyu.com/df2849ec.html"><meta property="og:site_name" content="一条奇怪鱼"><meta property="og:description" content="Java 语言有哪些特点? 面向对象（封装，继承，多态）  平台无关性（ Java 虚拟机实现平台无关性）  支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）  编译与解释并存   队列Queue 与 Deque 的区别Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.qiguaiyu.com/image/Java/Java.jpeg"><meta property="article:published_time" content="2022-12-18T17:49:55.000Z"><meta property="article:modified_time" content="2023-01-08T12:35:33.880Z"><meta property="article:author" content="Duibing"><meta property="article:tag" content="一条奇怪鱼"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.qiguaiyu.com/image/Java/Java.jpeg"><link rel="shortcut icon" href="/image/logo.png"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-title" class="inner"><h1 id="logo-wrap"> <a href="/" id="logo">一条奇怪鱼</a></h1></div><div id="header-inner" class="inner"><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/">主页</a> <a class="main-nav-link" href="/archives">归档</a></nav></div></div></header><div class="outer"><section id="main"><article id="post-Java" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting"><div class="article-meta"> <a href="/df2849ec.html" class="article-date"><time class="dt-published" datetime="2022-12-18T17:49:55.000Z" itemprop="datePublished">2022-12-19</time></a></div><div class="article-inner"><header class="article-header"><h1 class="p-name article-title" itemprop="headline name"> Java</h1></header><div class="article-entry" itemprop="articleBody"><p><img src="/./image/Java/Java.jpeg" alt="Java"></p><h1 id="Java-语言有哪些特点"><a href="#Java-语言有哪些特点" class="headerlink" title="Java 语言有哪些特点?"></a>Java 语言有哪些特点?</h1><ol><li><p>面向对象（封装，继承，多态）</p></li><li><p>平台无关性（ Java 虚拟机实现平台无关性）</p></li><li><p>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）</p></li><li><p>编译与解释并存</p></li></ol><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2><p>Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则</p><table><thead><tr><th>Queue 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><p>Deque 是双端队列，在队列的两端均可以插入或删除元素</p><p>Deque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><h2 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h2><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能</p><p><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现</p><p><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持</p><p><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)</p><p><code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢</p><blockquote><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈</p></blockquote><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队</p><ol><li><p>队列既可以根据元素的自然顺序来排序，也可以根据 Comparator来设置排序规则</p></li><li><p>通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素</p></li><li><p>是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己指定比较器进行排序</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="number">10</span>,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b; <span class="comment">//if a&gt;b 则交换，so这是递增序列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">queue.offer(<span class="number">13</span>);</span><br><span class="line">queue.offer(<span class="number">9</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 9  13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素的自然顺序来排序</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; queue2 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">queue2.offer(<span class="number">11</span>);</span><br><span class="line">queue2.offer(<span class="number">9</span>);</span><br><span class="line">len = queue2.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    System.out.println(queue2.poll());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 9， 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞队列和非阻塞队列区别"><a href="#阻塞队列和非阻塞队列区别" class="headerlink" title="阻塞队列和非阻塞队列区别"></a>阻塞队列和非阻塞队列区别</h2><p>阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现</p><p>阻塞队列相比非阻塞队列　提供了可阻塞的插入和移除的方法</p><p>插入-&gt;队列满再添加数据会堵塞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代表方法：put()</span><br></pre></td></tr></table></figure><p>移除并获取-&gt;队列null时会堵塞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代表方法：take()</span><br></pre></td></tr></table></figure><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><ol><li><p>一旦创建，容量不能改变</p></li><li><p>是 <code>BlockingQueue</code> 接口的有界队列实现类，底层采用数组来实现</p></li><li><p>默认情况下不能保证线程访问队列的公平性</p></li><li><p>如果保证公平性，通常会降低吞吐量</p></li></ol><p>公平性设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Integer&gt;(<span class="number">10</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><ol><li><p>底层基于<strong>单向链表</strong>实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性</p></li><li><p>与 <code>ArrayBlockingQueue</code> 相比起来具有更高的吞吐量</p></li><li></li></ol><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>简单地说，它就是 <code>PriorityQueue</code> 的线程安全版本</p><h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><ol><li><p>使用链表作为其数据结构</p></li><li><p>在高并发环境中性能比较好的队列</p></li><li><p>使用 CAS 非阻塞算法来实现线程安全</p></li><li><p>对队列加锁的成本较高则适合使用无锁的 <code>ConcurrentLinkedQueue</code> 来替代</p></li></ol></div><footer class="article-footer"></footer></div><nav id="article-nav"> <a href="/57ac2ca8.html" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">前一篇</strong><div class="article-nav-title"> HashMap遍历性能分析</div></a> <a href="/4a17b156.html" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">后一篇</strong><div class="article-nav-title">Hello World</div></a></nav></article></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">归档</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">最新文章</h3><div class="widget"><ul><li> <a href="/46e35c1e.html">JMeter</a></li><li> <a href="/228d20a7.html">Hikari连接池</a></li><li> <a href="/bae4ff13.html">Redis</a></li><li> <a href="/a6d8cedb.html">Java秒杀设计</a></li><li> <a href="/209c2dc1.html">性能测试参数理解</a></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner"> &copy; 2023 Duibing<br> Powered by <a href="https://qiguaiyu.com/" target="_blank">qiguaiyu.com</a></div></div></footer></div><nav id="mobile-nav"> <a href="/" class="mobile-nav-link">主页</a> <a href="/archives" class="mobile-nav-link">归档</a></nav><script src="/js/jquery-3.4.1.min.js"></script><script src="/fancybox/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></div></body></html>